#include "graph.hpp"

#include <algorithm>
#include <random>
#include <queue>
#include <stack>

// defining BFS, DFS and fill function, which fills an empty map with numOfNodes and randomly
// generated edges, preceded by its auxiliary functions

std::vector<int>& Graph::bfs(int const start, std::vector<int>& traversal) {
  assert(traversal.empty());

  std::vector<bool> visited(adjList_.size(), false);
  std::queue<int> queue;
  visited[start] = true;
  queue.push(start);

  while (!queue.empty()) {
    int current{queue.front()};
    queue.pop();
    traversal.push_back(current);

    for (int const& neighbor : adjList_[current]) {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        queue.push(neighbor);
      }
    }
  }

  return traversal;
}

std::vector<int>& Graph::dfs(int const start, std::vector<int>& traversal) {
  assert(traversal.empty());

  std::vector<bool> visited(adjList_.size(), false);
  std::stack<int> stack;
  visited[start] = true;
  stack.push(start);

  while (!stack.empty()) {
    int current{stack.top()};
    stack.pop();
    traversal.push_back(current);

    for (int const& neighbor : adjList_[current]) {
      if (!visited[neighbor]) {
        visited[neighbor] = true;
        stack.push(neighbor);
      }
    }
  }
  return traversal;
}

void printTraversal(std::vector<int> const& traversal) {
  for (int const& i : traversal) {
    std::cout << i << "  ";
  }
}

void removeElement(std::vector<int>::iterator const& element,
                   std::vector<int>& vec) {
  assert(element != vec.end());
  if (element + 1 != vec.end()) {
    std::rotate(element, element + 1, vec.end());
  }
  vec.pop_back();
}

std::vector<std::vector<int>>& generateRandomEdges(
    std::vector<std::vector<int>>& neighbors, int numOfNodes, int numOfEdges,
    unsigned int seed) {
  for (int i{}; i != numOfNodes; ++i) {
    // generates random unsigned ints
    std::default_random_engine eng(seed);
    // transforms the random unsigned int generated by gen into a random int
    // in the closed interval [a,b]
    std::uniform_int_distribution<> randomNeighbor(i + 1, numOfNodes - 1);
    int existingEdges{neighbors[i].size()};
    // if existingEdges >= numOfEdges, generate_n does nothing
    std::generate_n(std::back_inserter(neighbors[i]),
                    numOfEdges - existingEdges,
                    [&]() { return randomNeighbor(eng); });

    // removing possible duplicates
    std::sort(neighbors[i].begin(), neighbors[i].end());
    auto it{std::adjacent_find(neighbors[i].begin(), neighbors[i].end())};
    while (it != neighbors[i].end()) {
      removeElement(it, neighbors[i]);
      it = std::adjacent_find(neighbors[i].begin(), neighbors[i].end());
    }

    // adding i to the lists of its neighbors
    for (auto const& neighbor : neighbors[i]) {
      if (neighbor > i) {
        neighbors[neighbor].push_back(i);
      }
    }
  }

  return neighbors;
}

std::unordered_map<int, std::vector<int>>& fill(
    std::unordered_map<int, std::vector<int>>& adjList, int numOfNodes,
    int numOfEdges, unsigned int seed) {
  assert(numOfNodes > 1);
  assert(adjList.empty());

  // vector in which the nth entry represents the neighbors of the nth node
  std::vector<std::vector<int>> neighbors(numOfNodes);
  generateRandomEdges(neighbors, numOfNodes, numOfEdges, seed);
  for (int i{}; i != numOfNodes; ++i) {
    adjList[i] = neighbors[i];
  }

  return adjList;
}
